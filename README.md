# term_project
 _Komarov's  term project - application DocAnalyzer._
## Класс Paragraph(абзац)
**content** = предложения абзаца.

**type** = тип параграфа (title, plain, enum_head_, enum_part_, enum_last_).
- Заголовок(**title**) - базовый тип параграфа, 
в конце перенос строки или буква.
- Простой текст (**plain**) - заголовок, оканчивающийся точкой.
- Начало перечисления (**enum_head**_) - в конце стоит двоеточие, 
хранит объект, части которого перечисляются.
- Часть перечисления (**enum_part**_) - любой абзац 
после начала перечисления (возможно! оканчивающаяся точкой с запятой). 
Может быть также одновременно началом нового перечисления, 
но уже уровня на один больше. 
После обнаружения начала перечисления все последующие абзацы данного 
уровня будут определены частями перечисления данного уровня абзаца, 
пока не встретится конец перечисления.
- Конец перечисления (**enum_last**_) - первый абзац после начала
перечисления данного уровня, оканчивающийся точкой. 
Относится к уровню частей перечисления, 
но после него текущий уровень абзаца снижается на 1. 

#### level = уровень абзаца(то, как сильно он выступает, количество знаков табуляции в начале).

### метод parse_paragraphs()
1. Сохраняем список абзацев, как строк при помощи модуля docx-python.
2. Создаем:
   - **parsed_paragraphs** = пустой список, где будут объекты класса Paragraph из скачанных строк.
   - **curr_par_lvl** = динамическая переменная, хранит уровень абзаца, 
   на котором работаем.
   - **enum_started_lst** = массив размером с количество параграфов, 
   для каждого уровня храним: началось ли на этом уровне перечисление 
   или нет. (для **enum_head_** это **i** уровень, а для **enum_part_** 
   или **enum_last_** это **i - 1** уровень, то есть при начале перечисления, 
   на новый уровень сдвигаются все абзацы до конца включительно, 
   но не само начало)
   - **case_lst** = массив размером с количество параграфов, для каждого уровня 
   хранит регистр первого абзаца каждого уровня.
3. Перебираем переданные строки
4. Для начала в **curr_par_lvl** записываем наибольший уровень абзаца,
на котором началось и не закончилось перечисление.(если такого нет, имеем 0)
5. **type_of_par** = "", **last_ch** = последний символ текущего абзаца
(строки), пропуская неизвестные символы
(гарантировано буква, цифра, ":", ";" или "\n").
6. Если на предыдущем уровне абзаца есть активное перечисление, то:
   - проверяем, что для текущего уровня абзаца установлен тип регистра
     (если нет, то устанавливаем)
   - если в конце строки не стоит ";" и при этом регистр текущей строки
   не совпадает с предыдущими на этом же уровне, то мы спускаемся на 
   один уровень ниже
   - если последний символ строки - это точка, это значит, что это 
   последний член перечисления, устанавливаем соответствующий **type_of_par**,
   устанавливаем в **enum_started_lst** на предыдущем уровне False и 
   на текущем уровне обнуляем регистр в **case_lst**.
   - иначе это только часть перечисления, тогда записываем в **type_of_par**
   соответствующую запись.
7. Если последний символ = ":", то добавляем к type_of_par "**enum_start**_"
 и на текущем уровне устанавливаем **enum_started_lst** = True.
8. Если мы до сих пор не установили **type_of_par** и последний символ - точка,
то это простой текст.
9. Если **type_of_par** не установлен и точки нет, то это заголовок
10. Создаем объект **Paragraph**, передавая уровень абзаца, его тип и содержание
11. Добавляем его в возвращаемый массив.
   

### Метод get_last_true_index():
 - принимает булев массив;
 - возвращает последний ложный индекс элемента, стоящий после истинного.

## Класс ParagraphType(Enum):
 - представляет собой перечисление типов параграфа:
    - PLAIN = "plain_" - обычный текст
    - TITLE = "title_" - заголовок
    - ENUM_HEAD = "enum_head_" - начало перечисления
    - ENUM_PART = "enum_part_" - часть перечисления
    - ENUM_LAST = "enum_last_" - последний элемент перечисления

## Класс EndMarks(Enum):
 - представляет собой перечисление типов символов конца абзаца:
    - EMPTY = "" - пустой символ
    - POINT = "." - точка
    - SEMICOLON = ";" - точка с запятой
    - COLON = ":" - двоеточие